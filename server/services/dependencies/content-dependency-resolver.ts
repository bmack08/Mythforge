// Mythwright Content Dependency Resolution System - Task 86
// Intelligent system for managing content dependencies and cross-references

import type { 
  GenerationTask,
  Chapter,
  Section,
  Encounter,
  NPC,
  MagicItem,
  StatBlock
} from '../../types/content.types.js';

// ============================================================================
// DEPENDENCY RESOLUTION TYPES
// ============================================================================

export interface DependencyGraph {
  // Graph Structure
  nodes: Map<string, DependencyNode>;
  edges: Map<string, DependencyEdge[]>;
  
  // Analysis Results
  topologicalOrder: string[];
  circularDependencies: CircularDependency[];
  criticalPath: string[];
  
  // Metadata
  createdAt: Date;
  lastUpdated: Date;
  version: string;
}

export interface DependencyNode {
  // Node Identity
  nodeId: string;
  contentType: string;
  contentId: string;
  
  // Node Properties
  title: string;
  description: string;
  status: NodeStatus;
  priority: number; // 1-10, higher = more important
  
  // Dependency Information
  dependencies: string[]; // Node IDs this depends on
  dependents: string[]; // Node IDs that depend on this
  
  // Generation Information
  generationTask?: GenerationTask;
  estimatedDuration: number; // seconds
  actualDuration?: number;
  
  // Content Metadata
  tags: string[];
  category: string;
  metadata: Record<string, any>;
  
  // Timestamps
  createdAt: Date;
  updatedAt: Date;
  generatedAt?: Date;
}

export type NodeStatus = 
  | 'pending'      // Not yet processed
  | 'ready'        // Dependencies met, ready to process
  | 'processing'   // Currently being processed
  | 'completed'    // Successfully completed
  | 'failed'       // Failed to process
  | 'blocked'      // Blocked by failed dependencies
  | 'skipped';     // Skipped due to conditions

export interface DependencyEdge {
  // Edge Identity
  edgeId: string;
  fromNodeId: string;
  toNodeId: string;
  
  // Edge Properties
  dependencyType: DependencyType;
  strength: DependencyStrength;
  condition?: DependencyCondition;
  
  // Metadata
  reason: string;
  autoGenerated: boolean;
  createdAt: Date;
}

export type DependencyType = 
  | 'structural'    // Chapter contains section
  | 'narrative'     // Story continuation
  | 'character'     // NPC appears in multiple places
  | 'location'      // Location referenced across content
  | 'mechanical'    // Game mechanics dependency
  | 'thematic'      // Thematic consistency
  | 'cross_reference' // Explicit cross-reference
  | 'prerequisite'; // Must be completed first

export type DependencyStrength = 
  | 'required'      // Hard dependency - cannot proceed without
  | 'preferred'     // Soft dependency - better with, can work without
  | 'suggested'     // Weak dependency - minor improvement
  | 'informational'; // No functional dependency, just related

export interface DependencyCondition {
  type: 'content_exists' | 'field_value' | 'status_equals' | 'custom';
  field?: string;
  value?: any;
  customCheck?: (node: DependencyNode) => boolean;
}

export interface CircularDependency {
  cycle: string[]; // Node IDs forming the cycle
  severity: 'critical' | 'warning' | 'info';
  resolution: ResolutionStrategy;
  affectedNodes: string[];
}

export interface ResolutionStrategy {
  strategy: 'break_weakest' | 'merge_nodes' | 'reorder' | 'conditional' | 'manual';
  description: string;
  automaticFix: boolean;
  steps: ResolutionStep[];
}

export interface ResolutionStep {
  action: string;
  nodeId?: string;
  edgeId?: string;
  parameters?: Record<string, any>;
}

export interface DependencyAnalysis {
  // Graph Statistics
  totalNodes: number;
  totalEdges: number;
  averageDependencies: number;
  maxDependencyDepth: number;
  
  // Critical Path Analysis
  criticalPath: CriticalPathNode[];
  estimatedTotalDuration: number;
  bottlenecks: BottleneckAnalysis[];
  
  // Dependency Health
  healthScore: number; // 0-100
  issues: DependencyIssue[];
  recommendations: DependencyRecommendation[];
  
  // Parallelization Opportunities
  parallelizableGroups: ParallelGroup[];
  maxParallelism: number;
  efficiencyGain: number; // % time saved through parallelization
}

export interface CriticalPathNode {
  nodeId: string;
  cumulativeDuration: number;
  slack: number; // How much delay this node can tolerate
  isCritical: boolean;
}

export interface BottleneckAnalysis {
  nodeId: string;
  impact: number; // How much this bottleneck affects overall timeline
  reason: string;
  suggestions: string[];
}

export interface DependencyIssue {
  issueId: string;
  type: 'circular_dependency' | 'missing_dependency' | 'orphaned_node' | 'excessive_dependencies';
  severity: 'critical' | 'warning' | 'info';
  affectedNodes: string[];
  description: string;
  resolution?: ResolutionStrategy;
}

export interface DependencyRecommendation {
  type: 'optimization' | 'restructure' | 'parallelization' | 'caching';
  description: string;
  expectedBenefit: string;
  effort: 'low' | 'medium' | 'high';
  priority: number;
}

export interface ParallelGroup {
  groupId: string;
  nodes: string[];
  estimatedDuration: number; // Duration if processed in parallel
  sequentialDuration: number; // Duration if processed sequentially
  timeSavings: number;
}

// ============================================================================
// CONTENT DEPENDENCY RESOLVER CLASS
// ============================================================================

export class ContentDependencyResolver {
  private dependencyGraph: DependencyGraph;
  
  constructor() {
    this.dependencyGraph = this.initializeDependencyGraph();
  }
  
  // ========================================================================
  // GRAPH CONSTRUCTION
  // ========================================================================
  
  /**
   * Build dependency graph from generation tasks
   */
  async buildDependencyGraph(tasks: GenerationTask[]): Promise<DependencyGraph> {
    this.dependencyGraph = this.initializeDependencyGraph();
    
    // Create nodes for all tasks
    for (const task of tasks) {
      const node = this.createNodeFromTask(task);
      this.addNode(node);
    }
    
    // Create edges based on explicit dependencies
    for (const task of tasks) {
      for (const dependencyId of task.dependsOn) {
        const edge = this.createDependencyEdge(
          dependencyId,
          task.taskId,
          'prerequisite',
          'required',
          'Task explicitly depends on this'
        );
        this.addEdge(edge);
      }
    }
    
    // Analyze content to discover implicit dependencies
    await this.discoverImplicitDependencies();
    
    // Analyze graph structure
    await this.analyzeGraph();
    
    return this.dependencyGraph;
  }
  
  /**
   * Add a node to the dependency graph
   */
  addNode(node: DependencyNode): void {
    this.dependencyGraph.nodes.set(node.nodeId, node);
    this.dependencyGraph.lastUpdated = new Date();
  }
  
  /**
   * Add an edge to the dependency graph
   */
  addEdge(edge: DependencyEdge): void {
    const fromEdges = this.dependencyGraph.edges.get(edge.fromNodeId) || [];
    fromEdges.push(edge);
    this.dependencyGraph.edges.set(edge.fromNodeId, fromEdges);
    
    // Update node dependency lists
    const fromNode = this.dependencyGraph.nodes.get(edge.fromNodeId);
    const toNode = this.dependencyGraph.nodes.get(edge.toNodeId);
    
    if (fromNode && toNode) {
      if (!toNode.dependencies.includes(edge.fromNodeId)) {
        toNode.dependencies.push(edge.fromNodeId);
      }
      if (!fromNode.dependents.includes(edge.toNodeId)) {
        fromNode.dependents.push(edge.toNodeId);
      }
    }
    
    this.dependencyGraph.lastUpdated = new Date();
  }
  
  /**
   * Create a dependency node from a generation task
   */
  private createNodeFromTask(task: GenerationTask): DependencyNode {
    return {
      nodeId: task.taskId,
      contentType: task.taskType,
      contentId: task.contentId,
      title: this.generateNodeTitle(task),
      description: this.generateNodeDescription(task),
      status: this.mapTaskStatusToNodeStatus(task.status),
      priority: task.priority,
      dependencies: [...task.dependsOn],
      dependents: [],
      generationTask: task,
      estimatedDuration: task.estimatedDuration,
      tags: this.extractTagsFromTask(task),
      category: this.categorizeTask(task),
      metadata: { ...task.parameters },
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
  
  /**
   * Create a dependency edge
   */
  private createDependencyEdge(
    fromNodeId: string,
    toNodeId: string,
    type: DependencyType,
    strength: DependencyStrength,
    reason: string,
    condition?: DependencyCondition
  ): DependencyEdge {
    return {
      edgeId: `edge_${fromNodeId}_${toNodeId}_${Date.now()}`,
      fromNodeId,
      toNodeId,
      dependencyType: type,
      strength,
      condition,
      reason,
      autoGenerated: true,
      createdAt: new Date()
    };
  }
  
  // ========================================================================
  // IMPLICIT DEPENDENCY DISCOVERY
  // ========================================================================
  
  /**
   * Discover implicit dependencies by analyzing content relationships
   */
  private async discoverImplicitDependencies(): Promise<void> {
    const nodes = Array.from(this.dependencyGraph.nodes.values());
    
    // Discover structural dependencies
    await this.discoverStructuralDependencies(nodes);
    
    // Discover narrative dependencies
    await this.discoverNarrativeDependencies(nodes);
    
    // Discover character dependencies
    await this.discoverCharacterDependencies(nodes);
    
    // Discover location dependencies
    await this.discoverLocationDependencies(nodes);
    
    // Discover mechanical dependencies
    await this.discoverMechanicalDependencies(nodes);
    
    // Discover thematic dependencies
    await this.discoverThematicDependencies(nodes);
  }
  
  /**
   * Discover structural dependencies (chapters contain sections, etc.)
   */
  private async discoverStructuralDependencies(nodes: DependencyNode[]): Promise<void> {
    const chapters = nodes.filter(n => n.contentType === 'chapter');
    const sections = nodes.filter(n => n.contentType === 'section');
    const encounters = nodes.filter(n => n.contentType === 'encounter');
    
    // Chapters must exist before their sections
    for (const section of sections) {
      const chapterId = this.extractChapterIdFromSection(section);
      const chapter = chapters.find(c => c.contentId === chapterId);
      
      if (chapter && !this.hasEdge(chapter.nodeId, section.nodeId)) {
        const edge = this.createDependencyEdge(
          chapter.nodeId,
          section.nodeId,
          'structural',
          'required',
          'Section belongs to this chapter'
        );
        this.addEdge(edge);
      }
    }
    
    // Sections must exist before their encounters
    for (const encounter of encounters) {
      const sectionId = this.extractSectionIdFromEncounter(encounter);
      const section = sections.find(s => s.contentId === sectionId);
      
      if (section && !this.hasEdge(section.nodeId, encounter.nodeId)) {
        const edge = this.createDependencyEdge(
          section.nodeId,
          encounter.nodeId,
          'structural',
          'preferred',
          'Encounter belongs to this section'
        );
        this.addEdge(edge);
      }
    }
  }
  
  /**
   * Discover narrative dependencies (story flow)
   */
  private async discoverNarrativeDependencies(nodes: DependencyNode[]): Promise<void> {
    const storyNodes = nodes.filter(n => 
      ['chapter', 'section', 'narrative'].includes(n.contentType)
    ).sort((a, b) => {
      // Sort by chapter number, then section number
      const aChapter = this.extractChapterNumber(a);
      const bChapter = this.extractChapterNumber(b);
      if (aChapter !== bChapter) return aChapter - bChapter;
      
      const aSection = this.extractSectionNumber(a);
      const bSection = this.extractSectionNumber(b);
      return aSection - bSection;
    });
    
    // Create narrative flow dependencies
    for (let i = 1; i < storyNodes.length; i++) {
      const prevNode = storyNodes[i - 1];
      const currentNode = storyNodes[i];
      
      // Only create narrative dependencies within the same chapter
      if (this.extractChapterNumber(prevNode) === this.extractChapterNumber(currentNode)) {
        if (!this.hasEdge(prevNode.nodeId, currentNode.nodeId)) {
          const edge = this.createDependencyEdge(
            prevNode.nodeId,
            currentNode.nodeId,
            'narrative',
            'preferred',
            'Narrative flow continuation'
          );
          this.addEdge(edge);
        }
      }
    }
  }
  
  /**
   * Discover character dependencies (NPCs referenced across content)
   */
  private async discoverCharacterDependencies(nodes: DependencyNode[]): Promise<void> {
    const npcNodes = nodes.filter(n => n.contentType === 'npc');
    const contentNodes = nodes.filter(n => 
      ['chapter', 'section', 'encounter'].includes(n.contentType)
    );
    
    for (const npc of npcNodes) {
      const npcName = npc.title.toLowerCase();
      
      for (const content of contentNodes) {
        const contentText = this.extractContentText(content).toLowerCase();
        
        // Check if NPC is referenced in content
        if (contentText.includes(npcName)) {
          if (!this.hasEdge(npc.nodeId, content.nodeId)) {
            const edge = this.createDependencyEdge(
              npc.nodeId,
              content.nodeId,
              'character',
              'preferred',
              `NPC "${npc.title}" is referenced in this content`
            );
            this.addEdge(edge);
          }
        }
      }
    }
  }
  
  /**
   * Discover location dependencies
   */
  private async discoverLocationDependencies(nodes: DependencyNode[]): Promise<void> {
    // Extract location names from content and create dependencies
    const locationNames = this.extractLocationNames(nodes);
    const contentNodes = nodes.filter(n => 
      ['chapter', 'section', 'encounter'].includes(n.contentType)
    );
    
    for (const [locationName, definingNode] of locationNames) {
      for (const content of contentNodes) {
        if (content.nodeId === definingNode.nodeId) continue;
        
        const contentText = this.extractContentText(content).toLowerCase();
        
        if (contentText.includes(locationName.toLowerCase())) {
          if (!this.hasEdge(definingNode.nodeId, content.nodeId)) {
            const edge = this.createDependencyEdge(
              definingNode.nodeId,
              content.nodeId,
              'location',
              'suggested',
              `Location "${locationName}" is referenced in this content`
            );
            this.addEdge(edge);
          }
        }
      }
    }
  }
  
  /**
   * Discover mechanical dependencies (stat blocks, items, etc.)
   */
  private async discoverMechanicalDependencies(nodes: DependencyNode[]): Promise<void> {
    const mechanicalNodes = nodes.filter(n => 
      ['statblock', 'magic_item'].includes(n.contentType)
    );
    const encounterNodes = nodes.filter(n => n.contentType === 'encounter');
    
    for (const mechanical of mechanicalNodes) {
      for (const encounter of encounterNodes) {
        if (this.mechanicalContentUsedInEncounter(mechanical, encounter)) {
          if (!this.hasEdge(mechanical.nodeId, encounter.nodeId)) {
            const edge = this.createDependencyEdge(
              mechanical.nodeId,
              encounter.nodeId,
              'mechanical',
              'required',
              `${mechanical.contentType} is used in this encounter`
            );
            this.addEdge(edge);
          }
        }
      }
    }
  }
  
  /**
   * Discover thematic dependencies
   */
  private async discoverThematicDependencies(nodes: DependencyNode[]): Promise<void> {
    // Group nodes by theme and create weak dependencies within themes
    const themeGroups = this.groupNodesByTheme(nodes);
    
    for (const [theme, themeNodes] of themeGroups) {
      if (themeNodes.length < 2) continue;
      
      // Create weak dependencies between thematically related content
      for (let i = 0; i < themeNodes.length - 1; i++) {
        for (let j = i + 1; j < themeNodes.length; j++) {
          const nodeA = themeNodes[i];
          const nodeB = themeNodes[j];
          
          // Only create if no existing relationship
          if (!this.hasEdge(nodeA.nodeId, nodeB.nodeId) && 
              !this.hasEdge(nodeB.nodeId, nodeA.nodeId)) {
            
            const edge = this.createDependencyEdge(
              nodeA.nodeId,
              nodeB.nodeId,
              'thematic',
              'informational',
              `Both content pieces share "${theme}" theme`
            );
            this.addEdge(edge);
          }
        }
      }
    }
  }
  
  // ========================================================================
  // GRAPH ANALYSIS
  // ========================================================================
  
  /**
   * Analyze the dependency graph for issues and opportunities
   */
  private async analyzeGraph(): Promise<void> {
    // Detect circular dependencies
    this.dependencyGraph.circularDependencies = this.detectCircularDependencies();
    
    // Calculate topological order
    this.dependencyGraph.topologicalOrder = this.calculateTopologicalOrder();
    
    // Find critical path
    this.dependencyGraph.criticalPath = this.findCriticalPath();
  }
  
  /**
   * Detect circular dependencies in the graph
   */
  private detectCircularDependencies(): CircularDependency[] {
    const circularDeps: CircularDependency[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    
    const dfs = (nodeId: string, path: string[]): void => {
      if (recursionStack.has(nodeId)) {
        // Found a cycle
        const cycleStart = path.indexOf(nodeId);
        const cycle = path.slice(cycleStart);
        cycle.push(nodeId); // Complete the cycle
        
        circularDeps.push({
          cycle,
          severity: this.assessCycleSeverity(cycle),
          resolution: this.generateResolutionStrategy(cycle),
          affectedNodes: [...cycle]
        });
        return;
      }
      
      if (visited.has(nodeId)) return;
      
      visited.add(nodeId);
      recursionStack.add(nodeId);
      path.push(nodeId);
      
      const edges = this.dependencyGraph.edges.get(nodeId) || [];
      for (const edge of edges) {
        dfs(edge.toNodeId, [...path]);
      }
      
      recursionStack.delete(nodeId);
      path.pop();
    };
    
    // Check all nodes
    for (const nodeId of this.dependencyGraph.nodes.keys()) {
      if (!visited.has(nodeId)) {
        dfs(nodeId, []);
      }
    }
    
    return circularDeps;
  }
  
  /**
   * Calculate topological order of nodes
   */
  private calculateTopologicalOrder(): string[] {
    const inDegree = new Map<string, number>();
    const queue: string[] = [];
    const result: string[] = [];
    
    // Initialize in-degrees
    for (const nodeId of this.dependencyGraph.nodes.keys()) {
      inDegree.set(nodeId, 0);
    }
    
    // Calculate in-degrees
    for (const edges of this.dependencyGraph.edges.values()) {
      for (const edge of edges) {
        const currentDegree = inDegree.get(edge.toNodeId) || 0;
        inDegree.set(edge.toNodeId, currentDegree + 1);
      }
    }
    
    // Find nodes with no incoming edges
    for (const [nodeId, degree] of inDegree) {
      if (degree === 0) {
        queue.push(nodeId);
      }
    }
    
    // Process nodes
    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);
      
      const edges = this.dependencyGraph.edges.get(nodeId) || [];
      for (const edge of edges) {
        const newDegree = (inDegree.get(edge.toNodeId) || 1) - 1;
        inDegree.set(edge.toNodeId, newDegree);
        
        if (newDegree === 0) {
          queue.push(edge.toNodeId);
        }
      }
    }
    
    return result;
  }
  
  /**
   * Find the critical path through the dependency graph
   */
  private findCriticalPath(): string[] {
    const distances = new Map<string, number>();
    const predecessors = new Map<string, string | null>();
    
    // Initialize distances
    for (const nodeId of this.dependencyGraph.nodes.keys()) {
      distances.set(nodeId, 0);
      predecessors.set(nodeId, null);
    }
    
    // Calculate longest path (critical path)
    const topologicalOrder = this.dependencyGraph.topologicalOrder;
    
    for (const nodeId of topologicalOrder) {
      const node = this.dependencyGraph.nodes.get(nodeId);
      if (!node) continue;
      
      const edges = this.dependencyGraph.edges.get(nodeId) || [];
      for (const edge of edges) {
        const currentDistance = distances.get(nodeId) || 0;
        const targetNode = this.dependencyGraph.nodes.get(edge.toNodeId);
        const newDistance = currentDistance + (targetNode?.estimatedDuration || 0);
        
        if (newDistance > (distances.get(edge.toNodeId) || 0)) {
          distances.set(edge.toNodeId, newDistance);
          predecessors.set(edge.toNodeId, nodeId);
        }
      }
    }
    
    // Find the node with maximum distance (end of critical path)
    let maxDistance = 0;
    let endNode: string | null = null;
    
    for (const [nodeId, distance] of distances) {
      if (distance > maxDistance) {
        maxDistance = distance;
        endNode = nodeId;
      }
    }
    
    // Reconstruct critical path
    const criticalPath: string[] = [];
    let currentNode = endNode;
    
    while (currentNode) {
      criticalPath.unshift(currentNode);
      currentNode = predecessors.get(currentNode) || null;
    }
    
    return criticalPath;
  }
  
  // ========================================================================
  // DEPENDENCY RESOLUTION
  // ========================================================================
  
  /**
   * Resolve dependency conflicts and optimize the graph
   */
  async resolveDependencies(): Promise<DependencyAnalysis> {
    // Resolve circular dependencies
    await this.resolveCircularDependencies();
    
    // Optimize dependency structure
    await this.optimizeDependencyStructure();
    
    // Generate analysis report
    return this.generateDependencyAnalysis();
  }
  
  /**
   * Resolve circular dependencies
   */
  private async resolveCircularDependencies(): Promise<void> {
    for (const circularDep of this.dependencyGraph.circularDependencies) {
      if (circularDep.resolution.automaticFix) {
        await this.applyResolutionStrategy(circularDep.resolution);
      }
    }
  }
  
  /**
   * Apply a resolution strategy
   */
  private async applyResolutionStrategy(strategy: ResolutionStrategy): Promise<void> {
    for (const step of strategy.steps) {
      switch (step.action) {
        case 'remove_edge':
          if (step.edgeId) {
            this.removeEdge(step.edgeId);
          }
          break;
          
        case 'weaken_edge':
          if (step.edgeId) {
            this.weakenEdge(step.edgeId);
          }
          break;
          
        case 'add_condition':
          if (step.edgeId && step.parameters?.condition) {
            this.addConditionToEdge(step.edgeId, step.parameters.condition);
          }
          break;
          
        case 'merge_nodes':
          if (step.parameters?.nodeIds) {
            await this.mergeNodes(step.parameters.nodeIds);
          }
          break;
      }
    }
  }
  
  /**
   * Generate comprehensive dependency analysis
   */
  private generateDependencyAnalysis(): DependencyAnalysis {
    const nodes = Array.from(this.dependencyGraph.nodes.values());
    const totalEdges = Array.from(this.dependencyGraph.edges.values())
      .reduce((sum, edges) => sum + edges.length, 0);
    
    const criticalPath = this.calculateCriticalPathAnalysis();
    const bottlenecks = this.identifyBottlenecks();
    const parallelGroups = this.identifyParallelizableGroups();
    
    return {
      totalNodes: nodes.length,
      totalEdges,
      averageDependencies: nodes.length > 0 ? totalEdges / nodes.length : 0,
      maxDependencyDepth: this.calculateMaxDependencyDepth(),
      criticalPath,
      estimatedTotalDuration: this.calculateTotalDuration(),
      bottlenecks,
      healthScore: this.calculateHealthScore(),
      issues: this.identifyDependencyIssues(),
      recommendations: this.generateRecommendations(),
      parallelizableGroups: parallelGroups,
      maxParallelism: this.calculateMaxParallelism(),
      efficiencyGain: this.calculateEfficiencyGain(parallelGroups)
    };
  }
  
  // ========================================================================
  // UTILITY METHODS
  // ========================================================================
  
  private initializeDependencyGraph(): DependencyGraph {
    return {
      nodes: new Map(),
      edges: new Map(),
      topologicalOrder: [],
      circularDependencies: [],
      criticalPath: [],
      createdAt: new Date(),
      lastUpdated: new Date(),
      version: '1.0.0'
    };
  }
  
  private generateNodeTitle(task: GenerationTask): string {
    const typeMap: Record<string, string> = {
      chapter: 'Chapter',
      section: 'Section',
      encounter: 'Encounter',
      npc: 'NPC',
      magic_item: 'Magic Item',
      statblock: 'Stat Block',
      narrative: 'Narrative'
    };
    
    const prefix = typeMap[task.taskType] || task.taskType;
    return `${prefix}: ${task.contentId}`;
  }
  
  private generateNodeDescription(task: GenerationTask): string {
    return `Generate ${task.taskType} content for ${task.contentId}`;
  }
  
  private mapTaskStatusToNodeStatus(taskStatus: string): NodeStatus {
    const statusMap: Record<string, NodeStatus> = {
      pending: 'pending',
      running: 'processing',
      completed: 'completed',
      failed: 'failed',
      skipped: 'skipped'
    };
    
    return statusMap[taskStatus] || 'pending';
  }
  
  private extractTagsFromTask(task: GenerationTask): string[] {
    const tags = [task.taskType];
    
    if (task.parameters) {
      if (task.parameters.theme) tags.push(task.parameters.theme);
      if (task.parameters.difficulty) tags.push(task.parameters.difficulty);
      if (task.parameters.environment) tags.push(task.parameters.environment);
    }
    
    return tags;
  }
  
  private categorizeTask(task: GenerationTask): string {
    const categoryMap: Record<string, string> = {
      chapter: 'structure',
      section: 'structure',
      encounter: 'content',
      npc: 'character',
      magic_item: 'item',
      statblock: 'mechanics',
      narrative: 'story'
    };
    
    return categoryMap[task.taskType] || 'content';
  }
  
  private hasEdge(fromNodeId: string, toNodeId: string): boolean {
    const edges = this.dependencyGraph.edges.get(fromNodeId) || [];
    return edges.some(edge => edge.toNodeId === toNodeId);
  }
  
  private extractChapterIdFromSection(section: DependencyNode): string {
    // Extract chapter ID from section metadata or ID pattern
    if (section.metadata.chapterId) {
      return section.metadata.chapterId;
    }
    
    // Try to extract from ID pattern like "chapter_1_section_2"
    const match = section.contentId.match(/chapter_(\d+)_/);
    return match ? `chapter_${match[1]}` : '';
  }
  
  private extractSectionIdFromEncounter(encounter: DependencyNode): string {
    // Extract section ID from encounter metadata
    if (encounter.metadata.sectionId) {
      return encounter.metadata.sectionId;
    }
    
    // Try to extract from ID pattern
    const match = encounter.contentId.match(/(.+)_encounter_/);
    return match ? match[1] : '';
  }
  
  private extractChapterNumber(node: DependencyNode): number {
    if (node.metadata.chapterNumber) {
      return node.metadata.chapterNumber;
    }
    
    const match = node.contentId.match(/chapter_(\d+)/);
    return match ? parseInt(match[1]) : 0;
  }
  
  private extractSectionNumber(node: DependencyNode): number {
    if (node.metadata.sectionNumber) {
      return node.metadata.sectionNumber;
    }
    
    const match = node.contentId.match(/section_(\d+)/);
    return match ? parseInt(match[1]) : 0;
  }
  
  private extractContentText(node: DependencyNode): string {
    // Extract text content from node for analysis
    if (node.metadata.description) return node.metadata.description;
    if (node.metadata.content) return node.metadata.content;
    return node.description;
  }
  
  private extractLocationNames(nodes: DependencyNode[]): Map<string, DependencyNode> {
    const locations = new Map<string, DependencyNode>();
    
    // Simple location extraction - would be more sophisticated in practice
    const locationPatterns = [
      /\b([A-Z][a-z]+ (?:Castle|Tower|Keep|Hall|Temple|Shrine|Cave|Cavern|Forest|Woods|Mountain|Hill|Valley|River|Lake|Sea|Ocean|Desert|Plains|Swamp|Marsh))\b/g,
      /\bThe ([A-Z][a-z]+ (?:Tavern|Inn|Shop|Market|Square|District|Quarter|Ward))\b/g
    ];
    
    for (const node of nodes) {
      const text = this.extractContentText(node);
      
      for (const pattern of locationPatterns) {
        const matches = text.matchAll(pattern);
        for (const match of matches) {
          const locationName = match[0];
          if (!locations.has(locationName)) {
            locations.set(locationName, node);
          }
        }
      }
    }
    
    return locations;
  }
  
  private mechanicalContentUsedInEncounter(mechanical: DependencyNode, encounter: DependencyNode): boolean {
    const encounterText = this.extractContentText(encounter);
    const mechanicalName = mechanical.title.toLowerCase();
    
    return encounterText.toLowerCase().includes(mechanicalName);
  }
  
  private groupNodesByTheme(nodes: DependencyNode[]): Map<string, DependencyNode[]> {
    const themeGroups = new Map<string, DependencyNode[]>();
    
    for (const node of nodes) {
      for (const tag of node.tags) {
        const group = themeGroups.get(tag) || [];
        group.push(node);
        themeGroups.set(tag, group);
      }
    }
    
    return themeGroups;
  }
  
  private assessCycleSeverity(cycle: string[]): 'critical' | 'warning' | 'info' {
    // Assess based on cycle length and node types
    if (cycle.length > 5) return 'critical';
    if (cycle.some(nodeId => {
      const node = this.dependencyGraph.nodes.get(nodeId);
      return node?.contentType === 'chapter' || node?.contentType === 'section';
    })) return 'critical';
    
    return 'warning';
  }
  
  private generateResolutionStrategy(cycle: string[]): ResolutionStrategy {
    // Find the weakest edge in the cycle to break
    let weakestEdge: DependencyEdge | null = null;
    let weakestStrength = 'required';
    
    for (let i = 0; i < cycle.length - 1; i++) {
      const fromNode = cycle[i];
      const toNode = cycle[i + 1];
      const edges = this.dependencyGraph.edges.get(fromNode) || [];
      const edge = edges.find(e => e.toNodeId === toNode);
      
      if (edge && this.isWeakerStrength(edge.strength, weakestStrength)) {
        weakestEdge = edge;
        weakestStrength = edge.strength;
      }
    }
    
    return {
      strategy: 'break_weakest',
      description: `Break the weakest dependency edge in the cycle`,
      automaticFix: weakestStrength !== 'required',
      steps: weakestEdge ? [{
        action: 'weaken_edge',
        edgeId: weakestEdge.edgeId
      }] : []
    };
  }
  
  private isWeakerStrength(strength1: DependencyStrength, strength2: DependencyStrength): boolean {
    const strengthOrder = ['required', 'preferred', 'suggested', 'informational'];
    return strengthOrder.indexOf(strength1) > strengthOrder.indexOf(strength2);
  }
  
  private removeEdge(edgeId: string): void {
    for (const [nodeId, edges] of this.dependencyGraph.edges) {
      const filteredEdges = edges.filter(edge => edge.edgeId !== edgeId);
      if (filteredEdges.length !== edges.length) {
        this.dependencyGraph.edges.set(nodeId, filteredEdges);
        break;
      }
    }
  }
  
  private weakenEdge(edgeId: string): void {
    for (const edges of this.dependencyGraph.edges.values()) {
      const edge = edges.find(e => e.edgeId === edgeId);
      if (edge) {
        edge.strength = 'suggested';
        break;
      }
    }
  }
  
  private addConditionToEdge(edgeId: string, condition: DependencyCondition): void {
    for (const edges of this.dependencyGraph.edges.values()) {
      const edge = edges.find(e => e.edgeId === edgeId);
      if (edge) {
        edge.condition = condition;
        break;
      }
    }
  }
  
  private async mergeNodes(nodeIds: string[]): Promise<void> {
    // Implementation for merging nodes would go here
    // This is a complex operation that would require careful handling
  }
  
  private calculateCriticalPathAnalysis(): CriticalPathNode[] {
    // Implementation for detailed critical path analysis
    return [];
  }
  
  private identifyBottlenecks(): BottleneckAnalysis[] {
    // Implementation for bottleneck identification
    return [];
  }
  
  private identifyParallelizableGroups(): ParallelGroup[] {
    // Implementation for identifying parallelizable groups
    return [];
  }
  
  private calculateMaxDependencyDepth(): number {
    // Implementation for calculating maximum dependency depth
    return 0;
  }
  
  private calculateTotalDuration(): number {
    // Implementation for calculating total duration
    return 0;
  }
  
  private calculateHealthScore(): number {
    // Implementation for calculating dependency health score
    return 85; // Placeholder
  }
  
  private identifyDependencyIssues(): DependencyIssue[] {
    // Implementation for identifying dependency issues
    return [];
  }
  
  private generateRecommendations(): DependencyRecommendation[] {
    // Implementation for generating recommendations
    return [];
  }
  
  private calculateMaxParallelism(): number {
    // Implementation for calculating maximum parallelism
    return 1;
  }
  
  private calculateEfficiencyGain(parallelGroups: ParallelGroup[]): number {
    // Implementation for calculating efficiency gain
    return 0;
  }
  
  private async optimizeDependencyStructure(): Promise<void> {
    // Implementation for optimizing dependency structure
  }
  
  // ========================================================================
  // PUBLIC API
  // ========================================================================
  
  /**
   * Get the current dependency graph
   */
  getDependencyGraph(): DependencyGraph {
    return this.dependencyGraph;
  }
  
  /**
   * Get nodes that are ready to be processed (all dependencies met)
   */
  getReadyNodes(): DependencyNode[] {
    const readyNodes: DependencyNode[] = [];
    
    for (const node of this.dependencyGraph.nodes.values()) {
      if (node.status === 'pending' && this.areNodeDependenciesMet(node)) {
        readyNodes.push(node);
      }
    }
    
    return readyNodes.sort((a, b) => b.priority - a.priority);
  }
  
  /**
   * Check if all dependencies for a node are met
   */
  private areNodeDependenciesMet(node: DependencyNode): boolean {
    return node.dependencies.every(depId => {
      const depNode = this.dependencyGraph.nodes.get(depId);
      return depNode?.status === 'completed';
    });
  }
  
  /**
   * Update node status
   */
  updateNodeStatus(nodeId: string, status: NodeStatus): void {
    const node = this.dependencyGraph.nodes.get(nodeId);
    if (node) {
      node.status = status;
      node.updatedAt = new Date();
      
      if (status === 'completed') {
        node.generatedAt = new Date();
      }
      
      this.dependencyGraph.lastUpdated = new Date();
    }
  }
  
  /**
   * Get dependency analysis for the current graph
   */
  async getDependencyAnalysis(): Promise<DependencyAnalysis> {
    return this.generateDependencyAnalysis();
  }
}

// Export the dependency resolver
export default ContentDependencyResolver;
